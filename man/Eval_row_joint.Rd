% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Eval_row_joint.R
\name{Eval_row_joint}
\alias{Eval_row_joint}
\title{Evaluate the joint distribution between rows of a genomic assay.}
\usage{
Eval_row_joint(SE, HDER = "Row_joint", K = 3, ROW_STAND = T,
  RETURN_INDX = F)
}
\arguments{
\item{SE}{A \code{SummarizedExperiment} with features annotated by \code{\link{predictors.annot}}, the colnames of the SummarizedExperiment should be sample names.}

\item{HDER}{The subtitle and the file name of the plot.}

\item{K}{The number of centers used in K medoids clustering.}

\item{ROW_STAND}{Wheather standardize rows before clustering, default is TRUE.}

\item{RETURN_INDX}{Wheather to return the clustering index, default is FASLE.}
}
\value{
Plots saved under a directory named by \code{HDER}.
}
\description{
\code{Plot_column_joint} is a function used to evaluate the clustering quality between m6A sites.
}
\details{
By default, a K medoids clustering will be applied between rescaled row entires with metric of euclidean; then, a simplified heat map will be plotted.
Finally, a report by multinomial GLM is conducted using the clustering label and features.

The suggested quick check row number for SE should be less than 10000, otherwise this function would be time consuming.

About silhouette plot (from wikipedia).

The average silhouette of the data is another useful criterion for assessing the natural number of clusters.
The silhouette of a data instance is a measure of how closely it is matched to data within its cluster and how loosely it is matched to data of the neighbouring cluster,
i.e. the cluster whose average distance from the datum is lowest.
A silhouette close to 1 implies the datum is in an appropriate cluster, while a silhouette close to âˆ’1 implies the datum is in the wrong cluster.
Optimization techniques such as genetic algorithms are useful in determining the number of clusters that gives rise to the largest silhouette.
It is also possible to re-scale the data in such a way that the silhouette is more likely to be maximised at the correct number of clusters

About deviance in GLM (from stackexchange).

Let LL = loglikelihood
Here is a quick summary of what you see from the summary(glm.fit) output,
Null Deviance = 2(LL(Saturated Model) - LL(Null Model)) on df = df_Sat - df_Null
Residual Deviance = 2(LL(Saturated Model) - LL(Proposed Model)) df = df_Sat - df_Proposed
The Saturated Model is a model that assumes each data point has its own parameters (which means you have n parameters to estimate.)
The Null Model assumes the exact "opposite", in that is assumes one parameter for all of the data points, which means you only estimate 1 parameter.
The Proposed Model assumes you can explain your data points with p parameters + an intercept term, so you have p+1 parameters.
If your Null Deviance is really small, it means that the Null Model explains the data pretty well. Likewise with your Residual Deviance.
What does really small mean? If your model is "good" then your Deviance is approx Chi^2 with (df_sat - df_model) degrees of freedom.
If you want to compare you Null model with your Proposed model, then you can look at
(Null Deviance - Residual Deviance) approx Chi^2 with df Proposed - df Null = (n-(p+1))-(n-1)=p
Are the results you gave directly from R? They seem a little bit odd, because generally you should see that the degrees of freedom reported on the Null are always higher than the degrees of freedom reported on the Residual. That is because again, Null Deviance df = Saturated df - Null df = n-1 Residual Deviance df = Saturated df - Proposed df = n-(p+1)
}
\examples{
library(SummarizedExperiment)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(BSgenome.Hsapiens.UCSC.hg19)
library(fitCons.UCSC.hg19)
library(phastCons100way.UCSC.hg19)

Feature_List_expanded_hg19 = list(
 HNRNPC_eCLIP = eCLIP_HNRNPC_gr,
 YTHDC1_TREW = YTHDC1_TREW_gr,
 YTHDF1_TREW = YTHDF1_TREW_gr,
 YTHDF2_TREW = YTHDF2_TREW_gr,
 miR_targeted_genes = miR_targeted_genes_grl,
 TargetScan = TargetScan_hg19_gr,
 Verified_miRtargets = verified_targets_gr,
 METTL3_TREW = METTL3_TREW,
 METTL14_TREW = METTL14_TREW,
 WTAP_TREW = WTAP_TREW,
 METTL16_CLIP = METTL16_CLIP,
 ALKBH5_PARCLIP = ALKBH5_PARCLIP,
 FTO_CLIP = FTO_CLIP,
 FTO_eCLIP = FTO_eCLIP
)

SE_features_added <- predictors.annot(se = SE_CQN,
                                     txdb = TxDb.Hsapiens.UCSC.hg19.knownGene,
                                     bsgnm = Hsapiens,
                                     fc = fitCons.UCSC.hg19,
                                     pc = phastCons100way.UCSC.hg19,
                                     struct_hybridize = Struc_hg19,
                                     feature_lst = Feature_List_expanded_hg19,
                                     HK_genes_list = HK_hg19_eids)

Eval_row_joint(SE_features_added, "Row_joint_CQN")

}
\seealso{
\code{\link{predictors.annot}}
}
