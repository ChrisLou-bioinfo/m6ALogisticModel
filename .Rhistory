}else{
bg_class <- which.min( colSums( par_samples  ) )
}
rm(par_samples)
indx_bg <- mod_mix$classification == bg_class
table(indx_bg,Methylation_p[informative_bins_indx] == 0) #The labels are correctly classified having very high accuracies.
fisher.test(table(indx_bg,Methylation_p[informative_bins_indx] == 0))
p_hat <- mean( sapply(M_levels_RR, function(x){
m_prop_meth <- exp(x)[!indx_bg]
median(m_prop_meth) +  1 - max(m_prop_meth)
}) )
p_hat
p_hat2 <- mean( sapply(M_levels, function(x){
m_prop_meth <- exp(x)[!indx_bg]
median(m_prop_meth) +  1 - max(m_prop_meth)
}) )
p_hat2
p_hat <- mean( sapply(M_levels_RR, function(x){
m_prop_meth <- exp(x)[!indx_bg]
median(m_prop_meth) +  1 - quantile(m_prop_meth,.99)
}) )
p_hat2 <- mean( sapply(M_levels, function(x){
m_prop_meth <- exp(x)[!indx_bg]
median(m_prop_meth) +  1 - quantile(m_prop_meth,.99)
}) )
p_hat
p_hat2
mean(ground_truce_p[ground_truce_p>0])
ground_truce_p <- Methylation_p[informative_bins_indx]
mean(ground_truce_p[ground_truce_p>0])
p_hat <- mean( sapply(M_levels, function(x){
m_prop_meth <- exp(x)[!indx_bg]
median(m_prop_meth) +  1 - quantile(m_prop_meth,.998)
}) )
p_hat
table(indx_bg,Methylation_p[informative_bins_indx] == 0) #The labels are correctly classified having very high accuracies.
#Generating methylation ratio for each bins
Bin_num = 100000
Methylated_p = .3
set.seed(2)
#plot(dbeta(seq(0,1,.01),2,3),type = "l")
Methylation_p <- rbinom(n=Bin_num, size=1, p=Methylated_p)
Methylation_p[Methylation_p == 1] <- rbeta(n=sum(Methylation_p),2,3)
#Generating expression level for each bins
Expression <- rnorm(n = Bin_num, mean = 10, sd = 5)
Expression <- pmax(Expression,0)
#Generating reads count for each replicates
a = c(.8,.5,.6)
b = 1-a
s_IP = c(10,6,7)
s_input = c(2,3,1.5)
count_IP <- list()
count_input <- list()
for(i in seq_along(a)){
Lambda_IP <- Expression*(a[i]*Methylation_p+b[i])*s_IP[i]
Lambda_input <- Expression*s_IP[i]
count_IP[[i]] <- rpois(Bin_num, Lambda_IP)
count_input[[i]] <- rpois(Bin_num, Lambda_input)
}
#Visualize the bimodular distribution of the resulting counts
count_input_sum <- Reduce(function(x,y)x+y,count_input)
informative_bins_indx <- Reduce(function(x,y)x+y,c(count_input,count_IP)) > 50*2*length(a)
#Learn the Methylation labels using GMM
M_levels <- lapply(count_IP,function(x)log((x[informative_bins_indx]+1)/(count_input_sum[informative_bins_indx]+1)))
hist(M_levels[[1]],breaks = 100)
library(mclust)
model_matrix <- matrix(unlist(M_levels),ncol = length(a))
mod_mix <- densityMclust(model_matrix, G = 2, modelNames = "VVV")
par_samples <- mod_mix$parameters$mean
if(ncol(model_matrix) == 2){
bg_class <- which.min( par_samples )
}else{
bg_class <- which.min( colSums( par_samples  ) )
}
rm(par_samples)
indx_bg <- mod_mix$classification == bg_class
table(indx_bg,Methylation_p[informative_bins_indx] == 0) #The labels are correctly classified having very high accuracies.
#It is easy to estimate constant*(a/b) using the underlying method (the constant is the expectation methylation proportion, or the beta distribution)
a_to_b_hat <- sapply( count_IP, function(x){
count_inform <- x[informative_bins_indx]
return(((mean(count_inform[!indx_bg])-mean(count_inform[indx_bg]))/mean(count_inform[indx_bg])))
}
)
cor(a_to_b_hat, a/b)
#The real a, b calculation requires knowing the constant of expected methylation proportion of the methylated sites p...
p = .4 #Known
a_hat = a_to_b_hat/(p + a_to_b_hat)
b_hat = p/(p+a_to_b_hat)
#The problem is how to estimate p from data...
#The p can be conveniently estimated using the following method (assume the p is at maximum = 1).
p_hat <- mean( sapply(M_levels, function(x){
m_prop_meth <- exp(x)[!indx_bg]
median(m_prop_meth) +  1 - quantile(m_prop_meth,.998)
}) )
#This estimation may getting much better with ridge regression/MAP, but rightknow it is unstable.
ground_truce_p <- Methylation_p[informative_bins_indx]
mean(ground_truce_p[ground_truce_p>0])
p_hat
a_hat = a_to_b_hat/(p_hat + a_to_b_hat)
b_hat = p_hat/(p_hat + a_to_b_hat)
a
a_hat
b
b_hat
#Try to correct them using better methods
Methylation_p[informative_bins_indx]
p_hat <- mean( sapply(M_levels, function(x){
m_prop_meth <- exp(x)[!indx_bg]
median(m_prop_meth) +  1 - quantile(m_prop_meth,.998)
}) )
p_hat
mean( sapply(M_levels, function(x){
m_prop_meth <- exp(x)[indx_bg]
median(m_prop_meth) +  1 - quantile(m_prop_meth,.998)
}) )
a_hat = a_to_b_hat/(p + a_to_b_hat)
b_hat = p/(p+a_to_b_hat)
a_hat
b_hat
a_hat = a_to_b_hat/(p + a_to_b_hat)
cor(a,a_hat)
b_hat = p/(p+a_to_b_hat)
cor(b,b_hat)
p = .8 #Known
a_hat = a_to_b_hat/(p + a_to_b_hat)
cor(a,a_hat)
b_hat = p/(p+a_to_b_hat)
cor(b,b_hat)
a_hat
b_hat
a
b
x = M_levels
m_prop_meth <- exp(x)[!indx_bg]
m_prop_meth <- exp(x)[!indx_bg]
x = M_levels[[1]]
m_prop_meth <- exp(x)[!indx_bg]
m_prop_meth
median(m_prop_meth)
quantile(m_prop_meth,.998)
#The p can be conveniently estimated using the following method (assume the p is at maximum = 1).
p_hat <- mean( sapply(M_levels, function(x){
m_prop_meth <- exp(x)[!indx_bg]
median(m_prop_meth) +  1 - quantile(m_prop_meth,.998)
}) )
p_hat
m_prop_meth
p_hat <- mean( sapply(M_levels, function(x){
m_prop_meth <- exp(x)[!indx_bg] + 10
median(m_prop_meth) +  1 - quantile(m_prop_meth,.998)
}) )
p_hat
m_prop_meth
max(m_prop_met)
max(m_prop_meth)
#The p can be conveniently estimated using the following method (assume the p is at maximum = 1).
p_hat <- mean( sapply(M_levels, function(x){
m_prop_meth <- exp(x)[!indx_bg]
median(m_prop_meth) +  1 - max(m_prop_meth)
}) )
p_hat
hist(m_prop_meth)
mean(m_prop_meth)
#Learn the Methylation labels using GMM
M_levels <- lapply(count_IP,function(x)log((x[informative_bins_indx]+1)/(count_input_sum[informative_bins_indx]+1)))
Bin_num = 100000
Methylated_p = .3
set.seed(2)
#plot(dbeta(seq(0,1,.01),2,3),type = "l")
Methylation_p <- rbinom(n=Bin_num, size=1, p=Methylated_p)
Methylation_p[Methylation_p == 1] <- rbeta(n=sum(Methylation_p),2,3)
#Generating expression level for each bins
Expression <- rnorm(n = Bin_num, mean = 10, sd = 5)
Expression <- pmax(Expression,0)
#Generating reads count for each replicates
a = c(.8,.5,.6)
b = 1-a
s_IP = c(10,6,7)
s_input = c(2,3,1.5)
count_IP <- list()
count_input <- list()
for(i in seq_along(a)){
Lambda_IP <- Expression*(a[i]*Methylation_p+b[i])*s_IP[i]
Lambda_input <- Expression*s_IP[i]
count_IP[[i]] <- rpois(Bin_num, Lambda_IP)
count_input[[i]] <- rpois(Bin_num, Lambda_input)
}
#Visualize the bimodular distribution of the resulting counts
count_input_sum <- Reduce(function(x,y)x+y,count_input)
informative_bins_indx <- Reduce(function(x,y)x+y,c(count_input,count_IP)) > 50*2*length(a)
#Learn the Methylation labels using GMM
M_levels <- lapply(count_IP,function(x)log((x[informative_bins_indx]+1)/(count_input_sum[informative_bins_indx]+1)))
M_levels\
M_levels
exp(M_levels)
hist(M_levels[[1]],breaks = 100)
library(mclust)
model_matrix <- matrix(unlist(M_levels),ncol = length(a))
model_matrix
mod_mix <- densityMclust(model_matrix, G = 2, modelNames = "VVV")
par_samples <- mod_mix$parameters$mean
if(ncol(model_matrix) == 2){
bg_class <- which.min( par_samples )
}else{
bg_class <- which.min( colSums( par_samples  ) )
}
rm(par_samples)
indx_bg <- mod_mix$classification == bg_class
table(indx_bg,Methylation_p[informative_bins_indx] == 0) #The labels are correctly classified having very high accuracies.
#It is easy to estimate constant*(a/b) using the underlying method (the constant is the expectation methylation proportion, or the beta distribution)
a_to_b_hat <- sapply( count_IP, function(x){
count_inform <- x[informative_bins_indx]
return(((mean(count_inform[!indx_bg])-mean(count_inform[indx_bg]))/mean(count_inform[indx_bg])))
}
)
a_to_b_hat
a_to_b_hat
library(exomePeak2)
exomePeak2::exome_bins_from_txdb(txdb)
txdb <- GenomicFeatures::makeTxDbFromGFF("/Users/zhenwei/Documents/GitHub/JingTing_Thesis/SRV8.gff3")
exomePeak2::exome_bins_from_txdb(txdb)
library(exomePeak2)
debug(exome_bins_from_txdb)
exomePeak2::exome_bins_from_txdb(txdb)
exomePeak2::exome_bins_from_txdb(txdb)
bins_contain_introns
introns_each_bins
gr_bins
#Calculate intronic regions
Introns_iranges <- gaps(ranges(grl_exbg))
unlist_ebg <- unlist(grl_exbg)
seq_lev <- tapply(as.vector( seqnames(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
strand_lev <- tapply(as.vector( strand(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
#Find the mapping between introns and bins, for only those bins that "contain" introns.
introns_granges <- GRanges(
seqnames = rep(seq_lev, elementNROWS(Introns_iranges)),
ranges = unlist(Introns_iranges),
strand = rep(strand_lev, elementNROWS(Introns_iranges))
)
fol <- findOverlaps(introns_granges,
gr_bins,
type = "within")
#Remove all the hits that are inter-genes.
indx_keep <- names(introns_granges)[queryHits(fol)] == gsub("\\.[0-9]*$","",names(grl_exbg))[gr_bins$transcriptsHits[subjectHits(fol)]]
fol <- fol[indx_keep,]
#Split, and re-define the start and ends of those hitted bins.
indx_Hitted_bins <-  subjectHits(fol)
bins_contain_introns <- gr_bins[indx_Hitted_bins]
mcols(bins_contain_introns) <- NULL
names(bins_contain_introns) <- indx_Hitted_bins
#For each element within this GRanges, there is going to be an intron / multiple introns.
introns_each_bins <- introns_granges[queryHits(fol)]
names(introns_each_bins) <- indx_Hitted_bins
bins_contain_introns <- c(bins_contain_introns,introns_each_bins)
bins_contain_introns <- split(bins_contain_introns,names(bins_contain_introns))
#for some reason, disjoin is slow for huge granges list.
if(length(bins_contain_introns) = 0) {
indx_non_introns <- seq_along(gr_bins)
}else{
chunk_num = 1e5
index_start = 1
for(i in 1:ceiling( length(bins_contain_introns)/chunk_num )) {
Indx <- index_start: min(i*chunk_num, length(bins_contain_introns))
bins_contain_introns[Indx] <- disjoin(bins_contain_introns[Indx])
index_start = i*chunk_num + 1
}
#Remove the introns from those GRanges list.
bins_contain_introns <- unlist(bins_contain_introns)
bins_contain_introns <- subsetByOverlaps(bins_contain_introns,
introns_granges,
type = "equal",invert = TRUE)
indx_non_introns <- which( !1:length(gr_bins) %in% indx_Hitted_bins )
}
bins_without_granges <- gr_bins[indx_non_introns]
mcols(bins_without_granges) <- NULL
names(bins_without_granges) <- indx_non_introns
bins_intron_removed <- c(bins_without_granges,bins_contain_introns)
rm(bins_without_granges)
rm(bins_contain_introns)
bins_intron_removed <- bins_intron_removed[order(as.numeric(names(bins_intron_removed)))]
bins_intron_removed$gene_id <- names(grl_exbg)[gr_bins$transcriptsHits[as.integer( names(bins_intron_removed) )]]
names(bins_intron_removed) <- names(gr_bins)[as.integer( names(bins_intron_removed) )]
remove_introns <- function(gr_bins, grl_exbg){
#Calculate intronic regions
Introns_iranges <- gaps(ranges(grl_exbg))
unlist_ebg <- unlist(grl_exbg)
seq_lev <- tapply(as.vector( seqnames(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
strand_lev <- tapply(as.vector( strand(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
#Find the mapping between introns and bins, for only those bins that "contain" introns.
introns_granges <- GRanges(
seqnames = rep(seq_lev, elementNROWS(Introns_iranges)),
ranges = unlist(Introns_iranges),
strand = rep(strand_lev, elementNROWS(Introns_iranges))
)
fol <- findOverlaps(introns_granges,
gr_bins,
type = "within")
#Remove all the hits that are inter-genes.
indx_keep <- names(introns_granges)[queryHits(fol)] == gsub("\\.[0-9]*$","",names(grl_exbg))[gr_bins$transcriptsHits[subjectHits(fol)]]
fol <- fol[indx_keep,]
#Split, and re-define the start and ends of those hitted bins.
indx_Hitted_bins <-  subjectHits(fol)
bins_contain_introns <- gr_bins[indx_Hitted_bins]
mcols(bins_contain_introns) <- NULL
names(bins_contain_introns) <- indx_Hitted_bins
#For each element within this GRanges, there is going to be an intron / multiple introns.
introns_each_bins <- introns_granges[queryHits(fol)]
names(introns_each_bins) <- indx_Hitted_bins
bins_contain_introns <- c(bins_contain_introns,introns_each_bins)
bins_contain_introns <- split(bins_contain_introns,names(bins_contain_introns))
#for some reason, disjoin is slow for huge granges list.
if(length(bins_contain_introns) = 0) {
indx_non_introns <- seq_along(gr_bins)
}else{
chunk_num = 1e5
index_start = 1
for(i in 1:ceiling( length(bins_contain_introns)/chunk_num )) {
Indx <- index_start: min(i*chunk_num, length(bins_contain_introns))
bins_contain_introns[Indx] <- disjoin(bins_contain_introns[Indx])
index_start = i*chunk_num + 1
}
#Remove the introns from those GRanges list.
bins_contain_introns <- unlist(bins_contain_introns)
bins_contain_introns <- subsetByOverlaps(bins_contain_introns,
introns_granges,
type = "equal",invert = TRUE)
indx_non_introns <- which( !1:length(gr_bins) %in% indx_Hitted_bins )
}
bins_without_granges <- gr_bins[indx_non_introns]
mcols(bins_without_granges) <- NULL
names(bins_without_granges) <- indx_non_introns
bins_intron_removed <- c(bins_without_granges,bins_contain_introns)
rm(bins_without_granges)
rm(bins_contain_introns)
bins_intron_removed <- bins_intron_removed[order(as.numeric(names(bins_intron_removed)))]
bins_intron_removed$gene_id <- names(grl_exbg)[gr_bins$transcriptsHits[as.integer( names(bins_intron_removed) )]]
names(bins_intron_removed) <- names(gr_bins)[as.integer( names(bins_intron_removed) )]
return(bins_intron_removed)
}
remove_introns <- function(gr_bins, grl_exbg){
#Calculate intronic regions
Introns_iranges <- gaps(ranges(grl_exbg))
unlist_ebg <- unlist(grl_exbg)
seq_lev <- tapply(as.vector( seqnames(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
strand_lev <- tapply(as.vector( strand(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
#Find the mapping between introns and bins, for only those bins that "contain" introns.
introns_granges <- GRanges(
seqnames = rep(seq_lev, elementNROWS(Introns_iranges)),
ranges = unlist(Introns_iranges),
strand = rep(strand_lev, elementNROWS(Introns_iranges))
)
fol <- findOverlaps(introns_granges,
gr_bins,
type = "within")
#Remove all the hits that are inter-genes.
indx_keep <- names(introns_granges)[queryHits(fol)] == gsub("\\.[0-9]*$","",names(grl_exbg))[gr_bins$transcriptsHits[subjectHits(fol)]]
fol <- fol[indx_keep,]
#Split, and re-define the start and ends of those hitted bins.
indx_Hitted_bins <-  subjectHits(fol)
bins_contain_introns <- gr_bins[indx_Hitted_bins]
mcols(bins_contain_introns) <- NULL
names(bins_contain_introns) <- indx_Hitted_bins
#For each element within this GRanges, there is going to be an intron / multiple introns.
introns_each_bins <- introns_granges[queryHits(fol)]
names(introns_each_bins) <- indx_Hitted_bins
bins_contain_introns <- c(bins_contain_introns,introns_each_bins)
bins_contain_introns <- split(bins_contain_introns,names(bins_contain_introns))
#for some reason, disjoin is slow for huge granges list.
if(length(bins_contain_introns) = 0) {
indx_non_introns <- seq_along(gr_bins)
}else{
chunk_num = 1e5
index_start = 1
for(i in 1:ceiling( length(bins_contain_introns)/chunk_num )) {
Indx <- index_start: min(i*chunk_num, length(bins_contain_introns))
bins_contain_introns[Indx] <- disjoin(bins_contain_introns[Indx])
index_start = i*chunk_num + 1
}
#Remove the introns from those GRanges list.
bins_contain_introns <- unlist(bins_contain_introns)
bins_contain_introns <- subsetByOverlaps(bins_contain_introns,
introns_granges,
type = "equal",invert = TRUE)
indx_non_introns <- which( !1:length(gr_bins) %in% indx_Hitted_bins )
}
bins_without_granges <- gr_bins[indx_non_introns]
mcols(bins_without_granges) <- NULL
names(bins_without_granges) <- indx_non_introns
bins_intron_removed <- c(bins_without_granges,bins_contain_introns)
rm(bins_without_granges)
rm(bins_contain_introns)
bins_intron_removed <- bins_intron_removed[order(as.numeric(names(bins_intron_removed)))]
bins_intron_removed$gene_id <- names(grl_exbg)[gr_bins$transcriptsHits[as.integer( names(bins_intron_removed) )]]
names(bins_intron_removed) <- names(gr_bins)[as.integer( names(bins_intron_removed) )]
return(bins_intron_removed)
}
gr_bins
remove_introns <- function(gr_bins, grl_exbg){
#Calculate intronic regions
Introns_iranges <- gaps(ranges(grl_exbg))
unlist_ebg <- unlist(grl_exbg)
seq_lev <- tapply(as.vector( seqnames(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
strand_lev <- tapply(as.vector( strand(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
#Find the mapping between introns and bins, for only those bins that "contain" introns.
introns_granges <- GRanges(
seqnames = rep(seq_lev, elementNROWS(Introns_iranges)),
ranges = unlist(Introns_iranges),
strand = rep(strand_lev, elementNROWS(Introns_iranges))
)
fol <- findOverlaps(introns_granges,
gr_bins,
type = "within")
#Remove all the hits that are inter-genes.
indx_keep <- names(introns_granges)[queryHits(fol)] == gsub("\\.[0-9]*$","",names(grl_exbg))[gr_bins$transcriptsHits[subjectHits(fol)]]
fol <- fol[indx_keep,]
#Split, and re-define the start and ends of those hitted bins.
indx_Hitted_bins <-  subjectHits(fol)
bins_contain_introns <- gr_bins[indx_Hitted_bins]
mcols(bins_contain_introns) <- NULL
names(bins_contain_introns) <- indx_Hitted_bins
#For each element within this GRanges, there is going to be an intron / multiple introns.
introns_each_bins <- introns_granges[queryHits(fol)]
names(introns_each_bins) <- indx_Hitted_bins
bins_contain_introns <- c(bins_contain_introns,introns_each_bins)
bins_contain_introns <- split(bins_contain_introns,names(bins_contain_introns))
#for some reason, disjoin is slow for huge granges list.
if(length(bins_contain_introns) = 0) {
return(gr_bins)
}else{
chunk_num = 1e5
index_start = 1
for(i in 1:ceiling( length(bins_contain_introns)/chunk_num )) {
Indx <- index_start: min(i*chunk_num, length(bins_contain_introns))
bins_contain_introns[Indx] <- disjoin(bins_contain_introns[Indx])
index_start = i*chunk_num + 1
}
#Remove the introns from those GRanges list.
bins_contain_introns <- unlist(bins_contain_introns)
bins_contain_introns <- subsetByOverlaps(bins_contain_introns,
introns_granges,
type = "equal",invert = TRUE)
indx_non_introns <- which( !1:length(gr_bins) %in% indx_Hitted_bins )
bins_without_granges <- gr_bins[indx_non_introns]
mcols(bins_without_granges) <- NULL
names(bins_without_granges) <- indx_non_introns
bins_intron_removed <- c(bins_without_granges,bins_contain_introns)
rm(bins_without_granges)
rm(bins_contain_introns)
bins_intron_removed <- bins_intron_removed[order(as.numeric(names(bins_intron_removed)))]
bins_intron_removed$gene_id <- names(grl_exbg)[gr_bins$transcriptsHits[as.integer( names(bins_intron_removed) )]]
names(bins_intron_removed) <- names(gr_bins)[as.integer( names(bins_intron_removed) )]
return(bins_intron_removed)
}
}
remove_introns <- function(gr_bins, grl_exbg){
#Calculate intronic regions
Introns_iranges <- gaps(ranges(grl_exbg))
unlist_ebg <- unlist(grl_exbg)
seq_lev <- tapply(as.vector( seqnames(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
strand_lev <- tapply(as.vector( strand(unlist_ebg) ), names(unlist_ebg), function(x) x[1] )
#Find the mapping between introns and bins, for only those bins that "contain" introns.
introns_granges <- GRanges(
seqnames = rep(seq_lev, elementNROWS(Introns_iranges)),
ranges = unlist(Introns_iranges),
strand = rep(strand_lev, elementNROWS(Introns_iranges))
)
fol <- findOverlaps(introns_granges,
gr_bins,
type = "within")
#Remove all the hits that are inter-genes.
indx_keep <- names(introns_granges)[queryHits(fol)] == gsub("\\.[0-9]*$","",names(grl_exbg))[gr_bins$transcriptsHits[subjectHits(fol)]]
fol <- fol[indx_keep,]
#Split, and re-define the start and ends of those hitted bins.
indx_Hitted_bins <-  subjectHits(fol)
bins_contain_introns <- gr_bins[indx_Hitted_bins]
mcols(bins_contain_introns) <- NULL
names(bins_contain_introns) <- indx_Hitted_bins
#For each element within this GRanges, there is going to be an intron / multiple introns.
introns_each_bins <- introns_granges[queryHits(fol)]
names(introns_each_bins) <- indx_Hitted_bins
bins_contain_introns <- c(bins_contain_introns,introns_each_bins)
bins_contain_introns <- split(bins_contain_introns,names(bins_contain_introns))
#for some reason, disjoin is slow for huge granges list.
if(length(bins_contain_introns) == 0) {
return(gr_bins)
}else{
chunk_num = 1e5
index_start = 1
for(i in 1:ceiling( length(bins_contain_introns)/chunk_num )) {
Indx <- index_start: min(i*chunk_num, length(bins_contain_introns))
bins_contain_introns[Indx] <- disjoin(bins_contain_introns[Indx])
index_start = i*chunk_num + 1
}
#Remove the introns from those GRanges list.
bins_contain_introns <- unlist(bins_contain_introns)
bins_contain_introns <- subsetByOverlaps(bins_contain_introns,
introns_granges,
type = "equal",invert = TRUE)
indx_non_introns <- which( !1:length(gr_bins) %in% indx_Hitted_bins )
bins_without_granges <- gr_bins[indx_non_introns]
mcols(bins_without_granges) <- NULL
names(bins_without_granges) <- indx_non_introns
bins_intron_removed <- c(bins_without_granges,bins_contain_introns)
rm(bins_without_granges)
rm(bins_contain_introns)
bins_intron_removed <- bins_intron_removed[order(as.numeric(names(bins_intron_removed)))]
bins_intron_removed$gene_id <- names(grl_exbg)[gr_bins$transcriptsHits[as.integer( names(bins_intron_removed) )]]
names(bins_intron_removed) <- names(gr_bins)[as.integer( names(bins_intron_removed) )]
return(bins_intron_removed)
}
}
exomePeak2::exome_bins_from_txdb(txdb)
